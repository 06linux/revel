---
root: .
title: The Revel Web Framework for Go
---
<!DOCTYPE html>
<html lang="en">
  <head>
    {% include head.html %}
    <link href="{{ page.root }}/css/prettify.css" type="text/css" rel="stylesheet" />
    <script src="{{ page.root }}/js/prettify.js" type="text/javascript"></script>
    <script src="{{ page.root }}/js/lang-go-rich.js" type="text/javascript"></script>
		{% include analytics.html %}
  </head>

  <body onload="prettyPrint()">
    <a href="https://github.com/robfig/revel">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index:1000;"
           src="img/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>

    {% include topnav.html %}

    <header class="hero-unit">
      <div class="container">
        <div class="row" style="margin-left:-50px;">
          <div class="hero-img"><img src="img/RevelWhiteLines.png" height="500" width="350"></div>
          <div class="hero-text">
            <h1>Revel</h1>
            <p>A high-productivity web framework for the Go language,
              modeled on <a href="http://www.playframework.org">Play! Framework</a>.</p>
          </div>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="page-header">
        <h1>Features</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>Hot Compile</h2>
          <p>
            Edit, save, and refresh.  Revel compiles your code and templates for
            you, so you don't miss a beat.  Code doesn't compile?  It gives you a
            <a href="img/CompilationError.png">helpful description</a>.
            Run-time code panic?  Revel <a href="img/Panic.png">has you
            covered</a>.
          </p>
        </div>
        <div class="span4">
          <h2>Simplicity Optional</h2>
          <p>
            Revel tries to provide a comprehensive toolkit for making everyday
            web apps.
          </p>
          <p>
            Don't want to use some of the helpers?  Revel gets out of the way
            and gives you direct access to the underlying request and response.
          </p>
        </div>
        <div class="span4">
          <h2>Blocking</h2>
          <p>
            Revel builds on top of the
            <a href="http://golang.org/pkg/net/http/">Go HTTP server</a>,
            which runs each request in its own
            <a href="http://golang.org/doc/effective_go.html#goroutines">goroutine</a>.
            Write simple blocking code without guilt.
          </p>
        </div>
      </div>
      <div class="row">
      </div>
      <section id="quickstart">
        <div class="page-header">
          <h1>Quick Start</h1>
        </div>
        <div class="row">
          <div class="span6">
            <p>
              Revel ships with a couple sample applications to provide examples
              of real-world usage.
            </p>
            <p>
              You will need a <a href="http://golang.org/doc/install">functioning Go
              installation</a> for this to work.
            </p>
            <p>
              The commands at right will:
              <ol>
                <li>Install Revel into your GOPATH
                <li>Build the Revel command-line tool
                <li>Run the Chat sample application
              </ol>
              Once it's running,
              <a href="samples/chat.html">read how the chat demo is implemented</a>.
            </p>
          </div>
          <div class="span6" style="vertical-align:bottom;">
            <pre>
  # From the base of your GOPATH...
  go get github.com/robfig/revel
  go build -o bin/revel github.com/robfig/revel/cmd
  go get github.com/robfig/revel/samples/chat/app/controllers
  bin/revel run github.com/robfig/revel/samples/chat
            </pre>
          </div>
        </div>
      </section>

      <section id="development">
        <div class="page-header">
          <h1>Development Status <small>Early adopters only.  Pull requests welcome.</small></h1>
        </div>
				<p>
					Development is still very early.  Expect to get your hands dirty.
				</p>
      </section>

      <section id="teaser">
        <div class="page-header">
          <h1>Teaser</h1>
        </div>
        <p>
          This section gives you a taste of various parts of the framework:
        </p>

        <dl class="dl-horizontal">
          <dt><a href="#routing">Routing</a></dt>
          <dd>A simple declarative routing syntax</dd>

          <dt><a href="#controllers">Controllers</a></dt>
          <dd>
            Revel organizes endpoints into Controllers. They provide easy
            data binding and form validation.
          </dd>

          <dt><a href="#templates">Templates</a></dt>
          <dd>Revel makes Go Templates simple to use at scale.</dd>

          <dt><a href="#interceptors">Interceptors</a></dt>
          <dd>
            Register functionality to be called before or after actions.  They
            can be activated per action, per Controller, or globally.
          </dd>

          <dt><a href="#plugins">Plugins</a></dt>
          <dd>
            More general functionality (e.g. transaction management) can be
            implemented with Plugins.
          </dd>

        </dl>

        <div class="row">
          <div class="span6">
            <h2 id="routing">Routing</h2>
            <p>
              Revel uses the
              <a href="http://www.playframework.org/documentation/1.2.4/routes#syntax">
                original Play! routing syntax</a>. It collects all routes for an
              app in a single file, with a simple syntax for matching requests
              and extracting arguments from URIs.  Here's a commented sample...
            </p>
          </div>
          <div class="span12">
            <pre>
# conf/routes
# This file defines all application routes (Higher priority routes first)
GET    /login                 Application.Login      <b># A simple path</b>
GET    /hotels/?              Hotels.Index           <b># Match /hotels and /hotels/ (optional trailing slash)</b>
GET    /hotels/{id}           Hotels.Show            <b># Extract a URI argument (matching /[^/]+/)</b>
POST   /hotels/{<[0-9]+>id}   Hotels.Save            <b># URI arg with custom regex</b>
WS     /hotels/{id}/feed      Hotels.Feed            <b># WebSockets.</b>
POST   /hotels/{id}/{action}  Hotels.{action}        <b># Automatically route some actions.</b>
GET    /public/               staticDir:public       <b># Map /app/public resources under /public/...</b>
*      /{controller}/{action} {controller}.{action}  <b># Catch all; Automatic URL generation</b></pre>

          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="controllers">Controllers</h2>
            <p>
              All Actions are methods on a Controller.  This teaser shows a couple cool things:
              <ul>
                <li> <b>Data binding.</b>  Revel binds simple values and structs from
                  the URL or form and passes them as parameters to your method.
                  (If you prefer to access them directly from a parameter map, that's ok too!)
                <li> <b>Validation.</b> Helpers to manage validation errors.
                <li> <b>Flash.</b> The flash is a cookie that lives for one
                  request (errors, success messages, etc).
                <li> <b>Session.</b> The session is a cryptographically signed
                  cookie, exposed as a <code>map[string]string</code>.
                <li> <b>Results.</b> Redirections take advantage of reverse
                  routing.  Template rendering makes your data available using the
                  name of the local variable!
              </ul>

              Here's an example:
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-go">
// app/controllers/app.go

type Application struct {
	*rev.Controller
}

func (c Application) Register() rev.Result {
	title := "Register"
	return c.Render(title)
}

func (c Application) SaveUser(user models.User, verifyPassword string) rev.Result {
	c.Validation.Required(verifyPassword).Key("verifyPassword")
	c.Validation.Required(verifyPassword == user.Password).Key("verifyPassword").
		Message("Password does not match")
	user.Validate(c.Validation)

	if c.Validation.HasErrors() {
		c.Validation.Keep()
		c.FlashParams()
		return c.Redirect(Application.Register)
	}

	bcryptPassword, _ := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	_, err := c.Txn.Exec("insert into User (Username, HashedPassword, Name) values (?, ?, ?)",
		user.Username, bcryptPassword, user.Name)
	if err != nil {
		panic(err)
	}

	c.Session["user"] = user.Username
	c.Flash.Success("Welcome, " + user.Name)
	return c.Redirect(Hotels.Index)
}
            </pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="templates">Templates</h2>
            <p>
              By convention, Revel manages to integrate
              <a href="http://golang.org/pkg/text/template/">Go Templates</a>
              easily into the rest of the web app. Here is part of the template
              rendered in the <b>Register</b> action shown above.
            </p>
            Note that:
            <ul>
              <li> Revel found it automatically using the name of the action.
              <li> <b>field</b> is a simple helper function that returns a map
                of validation errors and parameter values for the named field.
                The app may inject any helper funcs that it wants.
              <li> The <b>title</b> variable is available in the template as if
                it had been explicitly put in the RenderArgs.  (It's used in
                <a href="http://github.com/robfig/revel/samples/booking/app/views/header.html">
                  header.html</a> in this case)
            </ul>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-html">{% capture teaser_template %}{% literal %}
{{/* app/views/Application/Register.html */}}

{{template "header.html" .}}

<h1>Register:</h1>
<form action="/register" method="POST">
  {{with $field := field "user.Username" .}}
    <p class="{{$field.ErrorClass}}">
      <strong>Username:</strong>
      <input type="text" name="{{$field.Name}}" size="16" value="{{$field.Value}}"> *
      <span class="error">{{$field.Error}}</span>
    </p>
  {{end}}

  {{/* other fields */}}

  <p class="buttons">
    <input type="submit" value="Register"> <a href="/">Cancel</a>
  </p>
</form>

{{template "footer.html" .}}{% endliteral %}{% endcapture %}{{ teaser_template|escape }}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="interceptors">Interceptors</h2>
            <p>
              Interceptors are useful for checking pre-conditions (e.g. that the
              user is logged in) and for cleaning up afterwards.
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// app/controllers/app.go

// This interceptor loads the user (using a helper).
// If it's nil, the user isn't logged in so it redirects them to the login page.
// Otherwise, it adds the user to the render context.
func checkLogin(c *rev.Controller) rev.Result {
	if user := connected(c); user != nil {
		c.RenderArgs["user"] = user
	} else {
		return c.Redirect(Application.Login)
	}
}

func init() {
	rev.InterceptFunc(checkLogin, rev.BEFORE, &Application{})
}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="plugins">Plugins</h2>
            <p>
              Any class that meets the Plugin interface may be registered.
            </p>
            <pre class="prettyprint">
type Plugin interface {
	OnAppStart()
	BeforeRequest(c *Controller)
	AfterRequest(c *Controller)
	OnException(c *Controller, err interface{})
}</pre>
            <p>
              An empty implementation is provided; clients can embed that and
              then implement only the hook of interest.  More hooks will be
              added as they are found useful.
            </p>
            <p>
              The booking sample app uses a plugin to manage its SQLite
              database.
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// app/controllers/db.go

import (
	_ "github.com/mattn/go-sqlite3"
	"github.com/robfig/revel"
)

var (
	db *sql.DB
)

type DbPlugin struct {
	rev.EmptyPlugin
}

func (p DbPlugin) OnAppStart() {
	db, _ = sql.Open("sqlite3", ":memory:")

	// Create tables and insert some records.
	db.Exec(`
create table User (
  UserId         integer primary key autoincrement,
  Username       varchar(20),
  HashedPassword blob,
  Name           varchar(100))`)

	bcryptPassword, _ := bcrypt.GenerateFromPassword(
		[]byte("demo"), bcrypt.DefaultCost)
	db.Exec("insert into User (Username, HashedPassword, Name)" +
		" values ('demo', ?, 'Demo User')", bcryptPassword)
}

// Start a new transaction for each request.
func (p DbPlugin) BeforeRequest(c *rev.Controller) {
	txn, _ := db.Begin()
	c.Txn = txn
}

// Commit the transaction at the conclusion.
func (p DbPlugin) AfterRequest(c *rev.Controller) {
	c.Txn.Commit()
	c.Txn = nil
}

// Rollback in the case of exception.
func (p DbPlugin) OnException(c *rev.Controller, err interface{}) {
	c.Txn.Rollback()
}

func init() {
	rev.RegisterPlugin(DbPlugin{})
}
            </pre>
          </div>

      </section>

      <section id="wishlist">
        <div class="page-header">
          <h1>Wishlist</h1>
        </div>
        <p>
          There are some areas that could benefit from some TLC.
        </p>
        <ul>
          <li> <b>ORM</b> -- A good ORM would make simple things simple.
            (Presently users can integrate something manually using a Plugin.)
            (e.g. <a href="http://github.com/coopernurse/gorp">gorp</a>)
          <li> <b>Reverse routing</b> -- A typesafe reverse router (usable from
            Controllers and Templates).
          <li> <b>Modules</b> -- Modules that share functionality across Revel
            apps.  A module repository that anyone can contribute to and install from.
          <li> <b>Testing</b> -- Tools to make it simple to test your web app.
        </ul>
      </section>

      <hr>

      <footer>
        <p>MIT License</p>
        <p>
          Gopher images remixed from those produced by
          <a href="http://www.golang.org">Go team</a>.
        </p>
      </footer>

    </div> <!-- /container -->

  </body>
</html>
