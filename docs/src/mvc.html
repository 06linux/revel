---
layout: godoc
---
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<h1>Mvc</h1>



	<pre>package rev

<span class="comment">// Flash represents a cookie that gets overwritten on each request.</span>
<span class="comment">// It allows data to be stored across one page at a time.</span>
<span class="comment">// This is commonly used to implement success or error messages.</span>
<span class="comment">// e.g. the Post/Redirect/Get pattern: http://en.wikipedia.org/wiki/Post/Redirect/Get</span>
type Flash struct {
    Data, Out map[string]string
}

<span class="comment">// These provide a unified view of the request params.</span>
<span class="comment">// Includes:</span>
<span class="comment">// - URL query string</span>
<span class="comment">// - Form values</span>
<span class="comment">// - File uploads</span>
type Params struct {
    url.Values
    Files map[string][]*multipart.FileHeader
    <span class="comment">// contains filtered or unexported fields</span>
}

<span class="comment">// A signed cookie (and thus limited to 4kb in size).</span>
<span class="comment">// Restriction: Keys may not have a colon in them.</span>
type Session map[string]string

type Request struct {
    *http.Request
    ContentType string
    Format      string <span class="comment">// &#34;html&#34;, &#34;xml&#34;, &#34;json&#34;, or &#34;text&#34;</span>
}

type Response struct {
    Status      int
    ContentType string

    Out http.ResponseWriter
}

type Controller struct {
    Name       string
    Type       *ControllerType
    MethodType *MethodType

    Request  *Request
    Response *Response

    Flash      Flash                  <span class="comment">// User cookie, cleared after each request.</span>
    Session    Session                <span class="comment">// Session, stored in cookie, signed.</span>
    Params     *Params                <span class="comment">// Parameters from URL and form (including multipart).</span>
    Args       map[string]interface{} <span class="comment">// Per-request scratch space.</span>
    RenderArgs map[string]interface{} <span class="comment">// Args passed to the template.</span>
    Validation *Validation            <span class="comment">// Data validation helpers</span>
    Txn        *sql.Tx                <span class="comment">// Nil by default, but may be used by the app / plugins</span>
}

func NewController(req *Request, resp *Response, ct *ControllerType) *Controller {
    flash := restoreFlash(req.Request)
    params := ParseParams(req)

    return &amp;Controller{
        Name:     ct.Type.Name(),
        Type:     ct,
        Request:  req,
        Response: resp,
        Params:   params,
        Flash:    flash,
        Session:  restoreSession(req.Request),
        RenderArgs: map[string]interface{}{
            &#34;RunMode&#34;: RunMode,
            &#34;flash&#34;:   flash.Data,
        },
        Validation: &amp;Validation{
            Errors: restoreValidationErrors(req.Request),
            keep:   false,
        },
    }
}

func NewRequest(r *http.Request) *Request {
    return &amp;Request{
        Request:     r,
        ContentType: ResolveContentType(r),
        Format:      ResolveFormat(r),
    }
}

func NewResponse(w http.ResponseWriter) *Response {
    return &amp;Response{Out: w}
}

func NewAppController(req *Request, resp *Response, controllerName, methodName string) (*Controller, reflect.Value) {
    var appControllerType *ControllerType = LookupControllerType(controllerName)
    if appControllerType == nil {
        INFO.Printf(&#34;Controller %s not found: %s&#34;, controllerName, req.URL)
        return nil, reflect.ValueOf(nil)
    }

    controller := NewController(req, resp, appControllerType)
    appControllerPtr := initNewAppController(appControllerType.Type, controller)

    controller.MethodType = appControllerType.Method(methodName)
    if controller.MethodType == nil {
        INFO.Println(&#34;Failed to find method&#34;, methodName, &#34;on Controller&#34;,
            controllerName)
        return nil, reflect.ValueOf(nil)
    }

    return controller, appControllerPtr
}

func (c *Controller) FlashParams() {
    for key, vals := range c.Params.Values {
        c.Flash.Out[key] = vals[0]
    }
}

func (c *Controller) SetCookie(cookie *http.Cookie) {
    http.SetCookie(c.Response.Out, cookie)
}

<span class="comment">// Invoke the given method, save headers/cookies to the response, and apply the</span>
<span class="comment">// result.  (e.g. render a template to the response)</span>
func (c *Controller) Invoke(appControllerPtr reflect.Value, method reflect.Value, methodArgs []reflect.Value) {

    defer func() {
        if err := recover(); err != nil {
            handleInvocationPanic(c, err)
        }
    }()

    defer func() {

        if c.Request.MultipartForm != nil {
            err := c.Request.MultipartForm.RemoveAll()
            if err != nil {
                WARN.Println(&#34;Error removing temporary files:&#34;, err)
            }
        }

        for _, tmpFile := range c.Params.tmpFiles {
            err := os.Remove(tmpFile.Name())
            if err != nil {
                WARN.Println(&#34;Could not remove upload temp file:&#34;, err)
            }
        }
    }()

    plugins.BeforeRequest(c)

    resultValue := func() reflect.Value {

        result := c.invokeInterceptors(BEFORE, appControllerPtr)
        if result != nil {
            return reflect.ValueOf(result)
        }

        resultValue := method.Call(methodArgs)[0]

        result = c.invokeInterceptors(AFTER, appControllerPtr)
        if result != nil {
            return reflect.ValueOf(result)
        }
        return resultValue
    }()

    plugins.AfterRequest(c)

    if resultValue.IsNil() {
        return
    }
    result := resultValue.Interface().(Result)

    <span class="comment">// Store the flash.</span>
    var flashValue string
    for key, value := range c.Flash.Out {
        flashValue += &#34;\x00&#34; + key + &#34;:&#34; + value + &#34;\x00&#34;
    }
    c.SetCookie(&amp;http.Cookie{
        Name:  COOKIE_PREFIX + &#34;_FLASH&#34;,
        Value: url.QueryEscape(flashValue),
        Path:  &#34;/&#34;,
    })

    <span class="comment">// Store the Validation errors</span>
    var errorsValue string
    if c.Validation.keep {
        for _, error := range c.Validation.Errors {
            if error.Message != &#34;&#34; {
                errorsValue += &#34;\x00&#34; + error.Key + &#34;:&#34; + error.Message + &#34;\x00&#34;
            }
        }
    }
    c.SetCookie(&amp;http.Cookie{
        Name:  COOKIE_PREFIX + &#34;_ERRORS&#34;,
        Value: url.QueryEscape(errorsValue),
        Path:  &#34;/&#34;,
    })

    <span class="comment">// Store the session (and sign it).</span>
    var sessionValue string
    for key, value := range c.Session {
        sessionValue += &#34;\x00&#34; + key + &#34;:&#34; + value + &#34;\x00&#34;
    }
    sessionData := url.QueryEscape(sessionValue)
    c.SetCookie(&amp;http.Cookie{
        Name:  COOKIE_PREFIX + &#34;_SESSION&#34;,
        Value: Sign(sessionData) + &#34;-&#34; + sessionData,
        Path:  &#34;/&#34;,
    })

    result.Apply(c.Request, c.Response)
}

func (c *Controller) RenderError(err error) Result {
    return ErrorResult{c.RenderArgs, err}
}

func RenderError(req *Request, resp *Response, err error) {
    stubController(req, resp).RenderError(err).Apply(req, resp)
}

<span class="comment">// Render a template corresponding to the calling Controller method.</span>
<span class="comment">// Arguments will be added to c.RenderArgs prior to rendering the template.</span>
<span class="comment">// They are keyed on their local identifier.</span>
<span class="comment">//</span>
<span class="comment">// For example:</span>
<span class="comment">//</span>
<span class="comment">//     func (c Users) ShowUser(id int) rev.Result {</span>
<span class="comment">//     	 user := loadUser(id)</span>
<span class="comment">//     	 return c.Render(user)</span>
<span class="comment">//     }</span>
<span class="comment">//</span>
<span class="comment">// This action will render views/Users/ShowUser.html, passing in an extra</span>
<span class="comment">// key-value &#34;user&#34;: (User).</span>
func (c *Controller) Render(extraRenderArgs ...interface{}) Result {

    pc, _, line, ok := runtime.Caller(1)
    if !ok {
        ERROR.Println(&#34;Failed to get Caller information&#34;)
        return nil
    }
    <span class="comment">// e.g. sample/app/controllers.(*Application).Index</span>
    var fqViewName string = runtime.FuncForPC(pc).Name()
    var viewName string = fqViewName[strings.LastIndex(fqViewName, &#34;.&#34;)+1 : len(fqViewName)]

    methodType := c.MethodType
    if methodType.Name != viewName {
        methodType = c.Type.Method(viewName)
        if methodType == nil {
            return c.RenderError(fmt.Errorf(
                &#34;No Method %s in Controller %s when loading the view.&#34;+
                    &#34; (delegating Render is only supported within the same controller)&#34;,
                viewName, c.Name))
        }
    }

    if renderArgNames, ok := methodType.RenderArgNames[line]; ok {
        if len(renderArgNames) == len(extraRenderArgs) {
            for i, extraRenderArg := range extraRenderArgs {
                c.RenderArgs[renderArgNames[i]] = extraRenderArg
            }
        } else {
            ERROR.Println(len(renderArgNames), &#34;RenderArg names found for&#34;,
                len(extraRenderArgs), &#34;extra RenderArgs&#34;)
        }
    } else {
        ERROR.Println(&#34;No RenderArg names found for Render call on line&#34;, line,
            &#34;(Method&#34;, methodType, &#34;, ViewName&#34;, viewName, &#34;)&#34;)
    }

    return c.RenderTemplate(c.Name + &#34;/&#34; + viewName + &#34;.html&#34;)
}

<span class="comment">// A less magical way to render a template.</span>
<span class="comment">// Renders the given template, using the current RenderArgs.</span>
func (c *Controller) RenderTemplate(templatePath string) Result {

    template, err := MainTemplateLoader.Template(templatePath)
    if err != nil {
        return c.RenderError(err)
    }

    c.RenderArgs[&#34;errors&#34;] = c.Validation.ErrorMap()

    return &amp;RenderTemplateResult{
        Template:   template,
        RenderArgs: c.RenderArgs,
    }
}

<span class="comment">// Uses encoding/json.Marshal to return JSON to the client.</span>
func (c *Controller) RenderJson(o interface{}) Result {
    return RenderJsonResult{o}
}

<span class="comment">// Uses encoding/xml.Marshal to return XML to the client.</span>
func (c *Controller) RenderXml(o interface{}) Result {
    return RenderXmlResult{o}
}

<span class="comment">// Render plaintext in response, printf style.</span>
func (c *Controller) RenderText(text string, objs ...interface{}) Result {
    finalText := text
    if len(objs) &gt; 0 {
        finalText = fmt.Sprintf(text, objs)
    }
    return &amp;RenderTextResult{finalText}
}

<span class="comment">// Render a &#34;todo&#34; indicating that the action isn&#39;t done yet.</span>
func (c *Controller) Todo() Result {
    c.Response.Status = http.StatusNotImplemented
    return c.RenderError(&amp;Error{
        Title:       &#34;TODO&#34;,
        Description: &#34;This action is not implemented&#34;,
    })
}

func (c *Controller) NotFound(msg string) Result {
    c.Response.Status = http.StatusNotFound
    return c.RenderError(&amp;Error{
        Title:       &#34;Not Found&#34;,
        Description: msg,
    })
}

<span class="comment">// This function is useful if there is no relevant Controller available.</span>
<span class="comment">// It writes the 404 response immediately.</span>
func NotFound(req *Request, resp *Response, msg string) {
    stubController(req, resp).NotFound(msg).Apply(req, resp)
}

<span class="comment">// Return a file, either displayed inline or downloaded as an attachment.</span>
<span class="comment">// The name and size are taken from the file info.</span>
func (c *Controller) RenderFile(file *os.File, delivery ContentDisposition) Result {
    var length int64 = -1
    fileInfo, err := file.Stat()
    if err != nil {
        WARN.Println(&#34;RenderFile error:&#34;, err)
    }
    if fileInfo != nil {
        length = fileInfo.Size()
    }
    return &amp;BinaryResult{
        Reader:   file,
        Name:     filepath.Base(file.Name()),
        Length:   length,
        Delivery: delivery,
    }
}

<span class="comment">// Redirect to an action or to a URL.</span>
<span class="comment">//   c.Redirect(Controller.Action)</span>
<span class="comment">//   c.Redirect(&#34;/controller/action&#34;)</span>
<span class="comment">//   c.Redirect(&#34;/controller/%d/action&#34;, id)</span>
func (c *Controller) Redirect(val interface{}, args ...interface{}) Result {
    if url, ok := val.(string); ok {
        if len(args) == 0 {
            return &amp;RedirectToUrlResult{url}
        }
        return &amp;RedirectToUrlResult{fmt.Sprintf(url, args...)}
    }
    return &amp;RedirectToActionResult{val}
}

func (f Flash) Error(msg string, args ...interface{}) {
    if len(args) == 0 {
        f.Out[&#34;error&#34;] = msg
    } else {
        f.Out[&#34;error&#34;] = fmt.Sprintf(msg, args...)
    }
}

func (f Flash) Success(msg string, args ...interface{}) {
    if len(args) == 0 {
        f.Out[&#34;success&#34;] = msg
    } else {
        f.Out[&#34;success&#34;] = fmt.Sprintf(msg, args...)
    }
}

func ParseParams(req *Request) *Params {
    var files map[string][]*multipart.FileHeader

    values := req.URL.Query()

    switch req.ContentType {
    case &#34;application/x-www-form-urlencoded&#34;:

        if err := req.ParseForm(); err != nil {
            WARN.Println(&#34;Error parsing request body:&#34;, err)
        } else {
            for key, vals := range req.Form {
                for _, val := range vals {
                    values.Add(key, val)
                }
            }
        }

    case &#34;multipart/form-data&#34;:

        if err := req.ParseMultipartForm(32 &lt;&lt; 20); err != nil {
            WARN.Println(&#34;Error parsing request body:&#34;, err)
        } else {
            for key, vals := range req.MultipartForm.Value {
                for _, val := range vals {
                    values.Add(key, val)
                }
            }
            files = req.MultipartForm.File
        }
    }

    return &amp;Params{Values: values, Files: files}
}

func (p *Params) Bind(name string, typ reflect.Type) reflect.Value {
    return Bind(p, name, typ)
}

<span class="comment">// Get the content type.</span>
<span class="comment">// e.g. From &#34;multipart/form-data; boundary=--&#34; to &#34;multipart/form-data&#34;</span>
<span class="comment">// If none is specified, returns &#34;text/html&#34; by default.</span>
func ResolveContentType(req *http.Request) string {
    contentType := req.Header.Get(&#34;Content-Type&#34;)
    if contentType == &#34;&#34; {
        return &#34;text/html&#34;
    }
    return strings.ToLower(strings.TrimSpace(strings.Split(contentType, &#34;;&#34;)[0]))
}

func ResolveFormat(req *http.Request) string {
    accept := req.Header.Get(&#34;accept&#34;)

    switch {
    case accept == &#34;&#34;,
        strings.HasPrefix(accept, &#34;*/*&#34;),
        strings.Contains(accept, &#34;application/xhtml&#34;),
        strings.Contains(accept, &#34;text/html&#34;):
        return &#34;html&#34;
    case strings.Contains(accept, &#34;application/xml&#34;),
        strings.Contains(accept, &#34;text/xml&#34;):
        return &#34;xml&#34;
    case strings.Contains(accept, &#34;text/plain&#34;):
        return &#34;txt&#34;
    case strings.Contains(accept, &#34;application/json&#34;),
        strings.Contains(accept, &#34;text/javascript&#34;):
        return &#34;json&#34;
    }

    return &#34;html&#34;
}

<span class="comment">// Write the header (for now, just the status code).</span>
<span class="comment">// The status may be set directly by the application (c.Response.Status = 501).</span>
<span class="comment">// if it isn&#39;t, then fall back to the provided status code.</span>
func (resp *Response) WriteHeader(defaultStatusCode int, defaultContentType string) {
    if resp.Status == 0 {
        resp.Status = defaultStatusCode
    }
    if resp.ContentType == &#34;&#34; {
        resp.ContentType = defaultContentType
    }
    resp.Out.Header().Set(&#34;Content-Type&#34;, resp.ContentType)
    resp.Out.WriteHeader(resp.Status)
}

var COOKIE_PREFIX string

type ControllerType struct {
    Type    reflect.Type
    Methods []*MethodType
}

type MethodType struct {
    Name           string
    Args           []*MethodArg
    RenderArgNames map[int][]string
    <span class="comment">// contains filtered or unexported fields</span>
}

type MethodArg struct {
    Name string
    Type reflect.Type
}

<span class="comment">// Searches for a given exported method (case insensitive)</span>
func (ct *ControllerType) Method(name string) *MethodType {
    lowerName := strings.ToLower(name)
    for _, method := range ct.Methods {
        if method.lowerName == lowerName {
            return method
        }
    }
    return nil
}

<span class="comment">// Register a Controller and its Methods with Revel.</span>
func RegisterController(c interface{}, methods []*MethodType) {
    <span class="comment">// De-star the controller type</span>
    <span class="comment">// (e.g. given TypeOf((*Application)(nil)), want TypeOf(Application))</span>
    var t reflect.Type = reflect.TypeOf(c)
    var elem reflect.Type = t.Elem()

    for _, m := range methods {
        m.lowerName = strings.ToLower(m.Name)
        for _, arg := range m.Args {
            arg.Type = arg.Type.Elem()
        }
    }

    controllers[strings.ToLower(elem.Name())] = &amp;ControllerType{Type: elem, Methods: methods}
    TRACE.Printf(&#34;Registered controller: %s&#34;, elem.Name())
}

func LookupControllerType(name string) *ControllerType {
    return controllers[strings.ToLower(name)]
}
</pre>






