---
layout: godoc
---
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<h1>Mvc</h1>



	<pre>package rev

func NewAppController(req *Request, resp *Response, controllerName, methodName string) (*Controller, reflect.Value) {
    var appControllerType *ControllerType = LookupControllerType(controllerName)
    if appControllerType == nil {
        INFO.Printf(&#34;Controller %s not found: %s&#34;, controllerName, req.URL)
        return nil, reflect.ValueOf(nil)
    }

    controller := NewController(req, resp, appControllerType)
    appControllerPtr := initNewAppController(appControllerType.Type, controller)

    <span class="comment">// Set the method being called.</span>
    controller.Action = controllerName + &#34;.&#34; + methodName
    controller.AppController = appControllerPtr.Interface()
    controller.MethodType = appControllerType.Method(methodName)
    if controller.MethodType == nil {
        INFO.Println(&#34;Failed to find method&#34;, methodName, &#34;on Controller&#34;,
            controllerName)
        return nil, reflect.ValueOf(nil)
    }

    return controller, appControllerPtr
}

func RenderError(req *Request, resp *Response, err error) {
    stubController(req, resp).RenderError(err).Apply(req, resp)
}

<span class="comment">// This function is useful if there is no relevant Controller available.</span>
<span class="comment">// It writes the 404 response immediately.</span>
func NotFound(req *Request, resp *Response, msg string) {
    stubController(req, resp).NotFound(msg).Apply(req, resp)
}

<span class="comment">// Write the header (for now, just the status code).</span>
<span class="comment">// The status may be set directly by the application (c.Response.Status = 501).</span>
<span class="comment">// if it isn&#39;t, then fall back to the provided status code.</span>
func (resp *Response) WriteHeader(defaultStatusCode int, defaultContentType string) {
    if resp.Status == 0 {
        resp.Status = defaultStatusCode
    }
    if resp.ContentType == &#34;&#34; {
        resp.ContentType = defaultContentType
    }
    resp.Out.Header().Set(&#34;Content-Type&#34;, resp.ContentType)
    resp.Out.WriteHeader(resp.Status)
}

<span class="comment">// Internal bookeeping</span>

type ControllerType struct {
    Type    reflect.Type
    Methods []*MethodType
}

type MethodType struct {
    Name           string
    Args           []*MethodArg
    RenderArgNames map[int][]string

}

type MethodArg struct {
    Name string
    Type reflect.Type
}

<span class="comment">// Searches for a given exported method (case insensitive)</span>
func (ct *ControllerType) Method(name string) *MethodType {
    lowerName := strings.ToLower(name)
    for _, method := range ct.Methods {
        if method.lowerName == lowerName {
            return method
        }
    }
    return nil
}

<span class="comment">// Register a Controller and its Methods with Revel.</span>
func RegisterController(c interface{}, methods []*MethodType) {
    <span class="comment">// De-star the controller type</span>
    <span class="comment">// (e.g. given TypeOf((*Application)(nil)), want TypeOf(Application))</span>
    var t reflect.Type = reflect.TypeOf(c)
    var elem reflect.Type = t.Elem()

    <span class="comment">// De-star all of the method arg types too.</span>
    for _, m := range methods {
        m.lowerName = strings.ToLower(m.Name)
        for _, arg := range m.Args {
            arg.Type = arg.Type.Elem()
        }
    }

    controllers[strings.ToLower(elem.Name())] = &amp;ControllerType{Type: elem, Methods: methods}
    TRACE.Printf(&#34;Registered controller: %s&#34;, elem.Name())
}

func LookupControllerType(name string) *ControllerType {
    return controllers[strings.ToLower(name)]
}
</pre>




