---
layout: godoc
---
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<h1>Validation</h1>



	<pre>package rev

type ValidationError struct {
    Message, Key string
}

<span class="comment">// Returns the Message.</span>
func (e *ValidationError) String() string {
    if e == nil {
        return &#34;&#34;
    }
    return e.Message
}

<span class="comment">// A Validation context manages data validation and error messages.</span>
type Validation struct {
    Errors []*ValidationError
    <span class="comment">// contains filtered or unexported fields</span>
}

func (v *Validation) Keep() {
    v.keep = true
}

func (v *Validation) Clear() {
    v.Errors = []*ValidationError{}
}

func (v *Validation) HasErrors() bool {
    return len(v.Errors) &gt; 0
}

<span class="comment">// Return the errors mapped by key.</span>
<span class="comment">// If there are multiple validation errors associated with a single key, the</span>
<span class="comment">// first one &#34;wins&#34;.  (Typically the first validation will be the more basic).</span>
func (v *Validation) ErrorMap() map[string]*ValidationError {
    m := map[string]*ValidationError{}
    for _, e := range v.Errors {
        if _, ok := m[e.Key]; !ok {
            m[e.Key] = e
        }
    }
    return m
}

<span class="comment">// Add an error to the validation context.</span>
func (v *Validation) Error(message string, args ...interface{}) *ValidationResult {
    return (&amp;ValidationResult{
        Ok:    false,
        Error: &amp;ValidationError{},
    }).Message(message, args)
}

<span class="comment">// A ValidationResult is returned from every validation method.</span>
<span class="comment">// It provides an indication of success, and a pointer to the Error (if any).</span>
type ValidationResult struct {
    Error *ValidationError
    Ok    bool
}

func (r *ValidationResult) Key(key string) *ValidationResult {
    if r.Error != nil {
        r.Error.Key = key
    }
    return r
}

func (r *ValidationResult) Message(message string, args ...interface{}) *ValidationResult {
    if r.Error != nil {
        if len(args) == 0 {
            r.Error.Message = message
        } else {
            r.Error.Message = fmt.Sprintf(message, args)
        }
    }
    return r
}

<span class="comment">// Test that the argument is non-nil and non-empty (if string or list)</span>
func (v *Validation) Required(obj interface{}) *ValidationResult {
    return v.apply(Required{}, obj)
}

func (v *Validation) Min(n int, min int) *ValidationResult {
    return v.apply(Min{min}, n)
}

func (v *Validation) Max(n int, max int) *ValidationResult {
    return v.apply(Max{max}, n)
}

func (v *Validation) Range(n, min, max int) *ValidationResult {
    return v.apply(Range{Min{min}, Max{max}}, n)
}

func (v *Validation) MinSize(obj interface{}, min int) *ValidationResult {
    return v.apply(MinSize{min}, obj)
}

func (v *Validation) MaxSize(obj interface{}, max int) *ValidationResult {
    return v.apply(MaxSize{max}, obj)
}

func (v *Validation) Length(obj interface{}, n int) *ValidationResult {
    return v.apply(Length{n}, obj)
}

func (v *Validation) Match(str string, regex *regexp.Regexp) *ValidationResult {
    return v.apply(Match{regex}, str)
}

func (v *Validation) Email(str string) *ValidationResult {
    return v.apply(Email{Match{emailPattern}}, str)
}

<span class="comment">// Apply a group of validators to a field, in order, and return the</span>
<span class="comment">// ValidationResult from the first one that fails, or the last one that</span>
<span class="comment">// succeeds.</span>
func (v *Validation) Check(obj interface{}, checks ...Validator) *ValidationResult {
    var result *ValidationResult
    for _, check := range checks {
        result = v.apply(check, obj)
        if !result.Ok {
            return result
        }
    }
    return result
}

type ValidationPlugin struct{ EmptyPlugin }

func (p ValidationPlugin) BeforeRequest(c *Controller) {
    c.Validation = &amp;Validation{
        Errors: restoreValidationErrors(c.Request.Request),
        keep:   false,
    }
}

func (p ValidationPlugin) AfterRequest(c *Controller) {

    c.RenderArgs[&#34;errors&#34;] = c.Validation.ErrorMap()

    <span class="comment">// Store the Validation errors</span>
    var errorsValue string
    if c.Validation.keep {
        for _, error := range c.Validation.Errors {
            if error.Message != &#34;&#34; {
                errorsValue += &#34;\x00&#34; + error.Key + &#34;:&#34; + error.Message + &#34;\x00&#34;
            }
        }
    }
    c.SetCookie(&amp;http.Cookie{
        Name:  CookiePrefix + &#34;_ERRORS&#34;,
        Value: url.QueryEscape(errorsValue),
        Path:  &#34;/&#34;,
    })
}

<span class="comment">// Register default validation keys for all calls to Controller.Validation.Func().</span>
<span class="comment">// Map from (package).func =&gt; (line =&gt; name of first arg to Validation func)</span>
<span class="comment">// E.g. &#34;myapp/controllers.helper&#34; or &#34;myapp/controllers.(*Application).Action&#34;</span>
<span class="comment">// This is set on initialization in the generated main.go file.</span>
var DefaultValidationKeys map[string]map[int]string
</pre>






