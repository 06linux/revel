---
layout: godoc
---
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<h1>Controller</h1>



	<pre>package revel

type Controller struct {
    Name          string          <span class="comment">// The controller name, e.g. &#34;Application&#34;</span>
    Type          *ControllerType <span class="comment">// A description of the controller type.</span>
    MethodType    *MethodType     <span class="comment">// A description of the invoked action type.</span>
    AppController interface{}     <span class="comment">// The controller that was instantiated.</span>
    Action        string          <span class="comment">// The full action name, e.g. &#34;Application.Index&#34;</span>

    Request  *Request
    Response *Response
    Result   Result

    Flash      Flash                  <span class="comment">// User cookie, cleared after 1 request.</span>
    Session    Session                <span class="comment">// Session, stored in cookie, signed.</span>
    Params     *Params                <span class="comment">// Parameters from URL and form (including multipart).</span>
    Args       map[string]interface{} <span class="comment">// Per-request scratch space.</span>
    RenderArgs map[string]interface{} <span class="comment">// Args passed to the template.</span>
    Validation *Validation            <span class="comment">// Data validation helpers</span>
    Txn        *sql.Tx                <span class="comment">// Nil by default, but may be used by the app / plugins</span>
}

func NewController(req *Request, resp *Response, ct *ControllerType) *Controller {
    c := &amp;Controller{
        Name:     ct.Type.Name(),
        Type:     ct,
        Request:  req,
        Response: resp,
        Params:   ParseParams(req),
        Args:     map[string]interface{}{},
        RenderArgs: map[string]interface{}{
            &#34;RunMode&#34;: RunMode,
        },
    }
    c.RenderArgs[&#34;Controller&#34;] = c
    return c
}

func (c *Controller) FlashParams() {
    for key, vals := range c.Params.Values {
        c.Flash.Out[key] = vals[0]
    }
}

func (c *Controller) SetCookie(cookie *http.Cookie) {
    http.SetCookie(c.Response.Out, cookie)
}

<span class="comment">// Invoke the given method, save headers/cookies to the response, and apply the</span>
<span class="comment">// result.  (e.g. render a template to the response)</span>
func (c *Controller) Invoke(appControllerPtr reflect.Value, method reflect.Value, methodArgs []reflect.Value) {

    <span class="comment">// Handle panics.</span>
    defer func() {
        if err := recover(); err != nil {
            handleInvocationPanic(c, err)
        }

        plugins.Finally(c)
    }()

    <span class="comment">// Clean up from the request.</span>
    defer func() {
        <span class="comment">// Delete temp files.</span>
        if c.Request.MultipartForm != nil {
            err := c.Request.MultipartForm.RemoveAll()
            if err != nil {
                WARN.Println(&#34;Error removing temporary files:&#34;, err)
            }
        }

        for _, tmpFile := range c.Params.tmpFiles {
            err := os.Remove(tmpFile.Name())
            if err != nil {
                WARN.Println(&#34;Could not remove upload temp file:&#34;, err)
            }
        }
    }()

    <span class="comment">// Run the plugins.</span>
    plugins.BeforeRequest(c)

    if c.Result == nil {
        <span class="comment">// Invoke the action.</span>
        var resultValue reflect.Value
        if method.Type().IsVariadic() {
            resultValue = method.CallSlice(methodArgs)[0]
        } else {
            resultValue = method.Call(methodArgs)[0]
        }
        if resultValue.Kind() == reflect.Interface &amp;&amp; !resultValue.IsNil() {
            c.Result = resultValue.Interface().(Result)
        }

        plugins.AfterRequest(c)
        if c.Result == nil {
            return
        }
    }

    <span class="comment">// Apply the result, which generally results in the ResponseWriter getting written.</span>
    c.Result.Apply(c.Request, c.Response)
}

func (c *Controller) RenderError(err error) Result {
    return ErrorResult{c.RenderArgs, err}
}

<span class="comment">// Render a template corresponding to the calling Controller method.</span>
<span class="comment">// Arguments will be added to c.RenderArgs prior to rendering the template.</span>
<span class="comment">// They are keyed on their local identifier.</span>
<span class="comment">//</span>
<span class="comment">// For example:</span>
<span class="comment">//</span>
<span class="comment">//     func (c Users) ShowUser(id int) revel.Result {</span>
<span class="comment">//     	 user := loadUser(id)</span>
<span class="comment">//     	 return c.Render(user)</span>
<span class="comment">//     }</span>
<span class="comment">//</span>
<span class="comment">// This action will render views/Users/ShowUser.html, passing in an extra</span>
<span class="comment">// key-value &#34;user&#34;: (User).</span>
func (c *Controller) Render(extraRenderArgs ...interface{}) Result {
    <span class="comment">// Get the calling function name.</span>
    pc, _, line, ok := runtime.Caller(1)
    if !ok {
        ERROR.Println(&#34;Failed to get Caller information&#34;)
        return nil
    }
    <span class="comment">// e.g. sample/app/controllers.(*Application).Index</span>
    var fqViewName string = runtime.FuncForPC(pc).Name()
    var viewName string = fqViewName[strings.LastIndex(fqViewName, &#34;.&#34;)+1 : len(fqViewName)]

    <span class="comment">// Determine what method we are in.</span>
    <span class="comment">// (e.g. the invoked controller method might have delegated to another method)</span>
    methodType := c.MethodType
    if methodType.Name != viewName {
        methodType = c.Type.Method(viewName)
        if methodType == nil {
            return c.RenderError(fmt.Errorf(
                &#34;No Method %s in Controller %s when loading the view.&#34;+
                    &#34; (delegating Render is only supported within the same controller)&#34;,
                viewName, c.Name))
        }
    }

    <span class="comment">// Get the extra RenderArgs passed in.</span>
    if renderArgNames, ok := methodType.RenderArgNames[line]; ok {
        if len(renderArgNames) == len(extraRenderArgs) {
            for i, extraRenderArg := range extraRenderArgs {
                c.RenderArgs[renderArgNames[i]] = extraRenderArg
            }
        } else {
            ERROR.Println(len(renderArgNames), &#34;RenderArg names found for&#34;,
                len(extraRenderArgs), &#34;extra RenderArgs&#34;)
        }
    } else {
        ERROR.Println(&#34;No RenderArg names found for Render call on line&#34;, line,
            &#34;(Method&#34;, methodType, &#34;, ViewName&#34;, viewName, &#34;)&#34;)
    }

    return c.RenderTemplate(c.Name + &#34;/&#34; + viewName + &#34;.&#34; + c.Request.Format)
}

<span class="comment">// A less magical way to render a template.</span>
<span class="comment">// Renders the given template, using the current RenderArgs.</span>
func (c *Controller) RenderTemplate(templatePath string) Result {

    <span class="comment">// Get the Template.</span>
    template, err := MainTemplateLoader.Template(templatePath)
    if err != nil {
        return c.RenderError(err)
    }

    return &amp;RenderTemplateResult{
        Template:   template,
        RenderArgs: c.RenderArgs,
    }
}

<span class="comment">// Uses encoding/json.Marshal to return JSON to the client.</span>
func (c *Controller) RenderJson(o interface{}) Result {
    return RenderJsonResult{o}
}

<span class="comment">// Uses encoding/xml.Marshal to return XML to the client.</span>
func (c *Controller) RenderXml(o interface{}) Result {
    return RenderXmlResult{o}
}

<span class="comment">// Render plaintext in response, printf style.</span>
func (c *Controller) RenderText(text string, objs ...interface{}) Result {
    finalText := text
    if len(objs) &gt; 0 {
        finalText = fmt.Sprintf(text, objs...)
    }
    return &amp;RenderTextResult{finalText}
}

<span class="comment">// Render a &#34;todo&#34; indicating that the action isn&#39;t done yet.</span>
func (c *Controller) Todo() Result {
    c.Response.Status = http.StatusNotImplemented
    return c.RenderError(&amp;Error{
        Title:       &#34;TODO&#34;,
        Description: &#34;This action is not implemented&#34;,
    })
}

func (c *Controller) NotFound(msg string, objs ...interface{}) Result {
    finalText := msg
    if len(objs) &gt; 0 {
        finalText = fmt.Sprintf(msg, objs...)
    }
    c.Response.Status = http.StatusNotFound
    return c.RenderError(&amp;Error{
        Title:       &#34;Not Found&#34;,
        Description: finalText,
    })
}

func (c *Controller) Forbidden(msg string, objs ...interface{}) Result {
    finalText := msg
    if len(objs) &gt; 0 {
        finalText = fmt.Sprintf(msg, objs...)
    }
    c.Response.Status = http.StatusForbidden
    return c.RenderError(&amp;Error{
        Title:       &#34;Forbidden&#34;,
        Description: finalText,
    })
}

<span class="comment">// Return a file, either displayed inline or downloaded as an attachment.</span>
<span class="comment">// The name and size are taken from the file info.</span>
func (c *Controller) RenderFile(file *os.File, delivery ContentDisposition) Result {
    var length int64 = -1
    fileInfo, err := file.Stat()
    if err != nil {
        WARN.Println(&#34;RenderFile error:&#34;, err)
    }
    if fileInfo != nil {
        length = fileInfo.Size()
    }
    return &amp;BinaryResult{
        Reader:   file,
        Name:     filepath.Base(file.Name()),
        Length:   length,
        Delivery: delivery,
    }
}

<span class="comment">// Redirect to an action or to a URL.</span>
<span class="comment">//   c.Redirect(Controller.Action)</span>
<span class="comment">//   c.Redirect(&#34;/controller/action&#34;)</span>
<span class="comment">//   c.Redirect(&#34;/controller/%d/action&#34;, id)</span>
func (c *Controller) Redirect(val interface{}, args ...interface{}) Result {
    if url, ok := val.(string); ok {
        if len(args) == 0 {
            return &amp;RedirectToUrlResult{url}
        }
        return &amp;RedirectToUrlResult{fmt.Sprintf(url, args...)}
    }
    return &amp;RedirectToActionResult{val}
}

<span class="comment">// Perform a message lookup for the given message name using the given arguments</span>
<span class="comment">// using the current language defined for this controller.</span>
<span class="comment">//</span>
<span class="comment">// The current language is set by the i18n plugin.</span>
func (c *Controller) Message(message string, args ...interface{}) (value string) {
    return Message(c.Request.Locale, message, args...)
}
</pre>




