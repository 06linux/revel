---
layout: godoc
---
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<h1>Template</h1>



	<pre>package rev

<span class="comment">// This object handles loading and parsing of templates.</span>
<span class="comment">// Everything below the application&#39;s views directory is treated as a template.</span>
type TemplateLoader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}

type Template interface {
    Name() string
    Content() []string
    Render(wr io.Writer, arg interface{}) error
}

type Field struct {
    Name, Value string
    Error       *ValidationError
}

func (f *Field) ErrorClass() string {
    if f.Error != nil {
        return &#34;hasError&#34;
    }
    return &#34;&#34;
}

<span class="comment">// Return &#34;checked&#34; if this field.Value matches the provided value</span>
func (f *Field) Checked(val string) string {
    if f.Value == val {
        return &#34;checked&#34;
    }
    return &#34;&#34;
}

var (
    <span class="comment">// The functions available for use in the templates.</span>
    Funcs = map[string]interface{}{
        &#34;url&#34;: ReverseUrl,
        &#34;eq&#34;:  func(a, b interface{}) bool { return a == b },

        &#34;set&#34;: func(key string, value interface{}, renderArgs map[string]interface{}) template.HTML {
            renderArgs[key] = value
            return template.HTML(&#34;&#34;)
        },
        &#34;append&#34;: func(key string, value interface{}, renderArgs map[string]interface{}) template.HTML {
            if renderArgs[key] == nil {
                renderArgs[key] = []interface{}{value}
            } else {
                renderArgs[key] = append(renderArgs[key].([]interface{}), value)
            }
            return template.HTML(&#34;&#34;)
        },
        &#34;field&#34;: func(name string, renderArgs map[string]interface{}) *Field {
            value, _ := renderArgs[&#34;flash&#34;].(map[string]string)[name]
            err, _ := renderArgs[&#34;errors&#34;].(map[string]*ValidationError)[name]
            return &amp;Field{
                Name:  name,
                Value: value,
                Error: err,
            }
        },
        &#34;option&#34;: func(f *Field, val, label string) template.HTML {
            selected := &#34;&#34;
            if f.Value == val {
                selected = &#34; selected&#34;
            }
            return template.HTML(fmt.Sprintf(`&lt;option value=&#34;%s&#34;%s&gt;%s&lt;/option&gt;`,
                html.EscapeString(val), selected, html.EscapeString(label)))
        },
        &#34;radio&#34;: func(f *Field, val string) template.HTML {
            checked := &#34;&#34;
            if f.Value == val {
                checked = &#34; checked&#34;
            }
            return template.HTML(fmt.Sprintf(`&lt;input type=&#34;radio&#34; name=&#34;%s&#34; value=&#34;%s&#34;%s&gt;`,
                html.EscapeString(f.Name), html.EscapeString(val), checked))
        },
    }
)

func NewTemplateLoader(paths ...string) *TemplateLoader {

    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        LOG.Fatal(err)
    }

    watcher.Event = make(chan *fsnotify.FileEvent, 10)
    watcher.Error = make(chan error, 10)

    for _, p := range paths {
        filepath.Walk(p, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                LOG.Println(&#34;Error walking path:&#34;, err)
                return nil
            }
            if info.IsDir() {
                err = watcher.Watch(path)
                if err != nil {
                    LOG.Println(&#34;Failed to watch&#34;, path, &#34;:&#34;, err)
                }
            }
            return nil
        })
    }

    loader := &amp;TemplateLoader{
        watcher: watcher,
        paths:   paths,
    }
    loader.refresh()
    return loader
}

<span class="comment">// Return the Template with the given name.  The name is the template&#39;s path</span>
<span class="comment">// relative to a template loader root.</span>
<span class="comment">//</span>
<span class="comment">// An Error is returned if there was any problem with any of the templates.  (In</span>
<span class="comment">// this case, if a template is returned, it may still be usable.)</span>
<span class="comment">//</span>
<span class="comment">// TODO: Might be better to separate out the watching from the template loader.</span>
<span class="comment">// Then the server could be aware when it&#39;s refreshing, and query for new</span>
<span class="comment">// template errors at that time.</span>
func (loader *TemplateLoader) Template(name string) (Template, error) {

    refresh := false
    for {
        select {
        case ev := &lt;-loader.watcher.Event:

            if !strings.HasPrefix(path.Base(ev.Name), &#34;.&#34;) {
                refresh = true
            }
            continue
        case &lt;-loader.watcher.Error:
            continue
        default:

        }
        break
    }

    if refresh {
        loader.refresh()
    }

    tmpl := loader.templateSet.Lookup(name)
    if tmpl == nil {

        <span class="comment">// Probably there is a compileError set, but if not, set one saying that it</span>
        <span class="comment">// wasn&#39;t found.</span>
        var err error = loader.compileError
        if err == nil {
            err = fmt.Errorf(&#34;Template %s not found.&#34;, name)
        }

        return nil, err
    }

    <span class="comment">// This is necessary.</span>
    <span class="comment">// If a nil loader.compileError is returned directly, a caller testing against</span>
    <span class="comment">// nil will get the wrong result.  Something to do with casting *Error to error.</span>
    var err error
    if loader.compileError != nil {
        err = loader.compileError
    }

    return GoTemplate{tmpl, loader}, err
}

<span class="comment">// Adapter for Go Templates.</span>
type GoTemplate struct {
    *template.Template
    <span class="comment">// contains filtered or unexported fields</span>
}

<span class="comment">// return a &#39;rev.Template&#39; from Go&#39;s template.</span>
func (gotmpl GoTemplate) Render(wr io.Writer, arg interface{}) error {
    return gotmpl.Execute(wr, arg)
}

func (gotmpl GoTemplate) Content() []string {
    content, _ := ReadLines(gotmpl.loader.templatePaths[gotmpl.Name()])
    return content
}

<span class="comment">// Return a url capable of invoking a given controller method:</span>
<span class="comment">// &#34;Application.ShowApp 123&#34; =&gt; &#34;/app/123&#34;</span>
func ReverseUrl(args ...interface{}) string {
    if len(args) == 0 {
        LOG.Println(&#34;Warning: no arguments provided to url function&#34;)
        return &#34;#&#34;
    }

    action := args[0].(string)
    actionSplit := strings.Split(action, &#34;.&#34;)
    var ctrl, meth string
    if len(actionSplit) != 2 {
        LOG.Println(&#34;Warning: Must provide Controller.Method for reverse router.&#34;)
        return &#34;#&#34;
    }
    ctrl, meth = actionSplit[0], actionSplit[1]
    controllerType := LookupControllerType(ctrl)
    methodType := controllerType.Method(meth)
    argsByName := make(map[string]string)
    for i, argValue := range args[1:] {
        argsByName[methodType.Args[i].Name] = fmt.Sprintf(&#34;%s&#34;, argValue)
    }

    return router.Reverse(args[0].(string), argsByName).Url
}
</pre>






