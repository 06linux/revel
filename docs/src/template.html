---
layout: godoc
---
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<h1>Template</h1>



	<pre>package rev

<span class="comment">// This object handles loading and parsing of templates.</span>
<span class="comment">// Everything below the application&#39;s views directory is treated as a template.</span>
type TemplateLoader struct {

}

type Template interface {
    Name() string
    Content() []string
    Render(wr io.Writer, arg interface{}) error
}

type Field struct {
    Name, Value string
    Error       *ValidationError
}

func (f *Field) ErrorClass() string {
    if f.Error != nil {
        return &#34;hasError&#34;
    }
    return &#34;&#34;
}

<span class="comment">// Return &#34;checked&#34; if this field.Value matches the provided value</span>
func (f *Field) Checked(val string) string {
    if f.Value == val {
        return &#34;checked&#34;
    }
    return &#34;&#34;
}

var (
    <span class="comment">// The functions available for use in the templates.</span>
    Funcs = map[string]interface{}{
        &#34;url&#34;: ReverseUrl,
        &#34;eq&#34;:  func(a, b interface{}) bool { return a == b },
        &#34;set&#34;: func(key string, value interface{}, renderArgs map[string]interface{}) template.HTML {
            renderArgs[key] = value
            return template.HTML(&#34;&#34;)
        },
        &#34;append&#34;: func(key string, value interface{}, renderArgs map[string]interface{}) template.HTML {
            if renderArgs[key] == nil {
                renderArgs[key] = []interface{}{value}
            } else {
                renderArgs[key] = append(renderArgs[key].([]interface{}), value)
            }
            return template.HTML(&#34;&#34;)
        },
        &#34;field&#34;: func(name string, renderArgs map[string]interface{}) *Field {
            value, _ := renderArgs[&#34;flash&#34;].(map[string]string)[name]
            err, _ := renderArgs[&#34;errors&#34;].(map[string]*ValidationError)[name]
            return &amp;Field{
                Name:  name,
                Value: value,
                Error: err,
            }
        },
        &#34;option&#34;: func(f *Field, val, label string) template.HTML {
            selected := &#34;&#34;
            if f.Value == val {
                selected = &#34; selected&#34;
            }
            return template.HTML(fmt.Sprintf(`&lt;option value=&#34;%s&#34;%s&gt;%s&lt;/option&gt;`,
                html.EscapeString(val), selected, html.EscapeString(label)))
        },
        &#34;radio&#34;: func(f *Field, val string) template.HTML {
            checked := &#34;&#34;
            if f.Value == val {
                checked = &#34; checked&#34;
            }
            return template.HTML(fmt.Sprintf(`&lt;input type=&#34;radio&#34; name=&#34;%s&#34; value=&#34;%s&#34;%s&gt;`,
                html.EscapeString(f.Name), html.EscapeString(val), checked))
        },

        <span class="comment">// Pads the given string with &amp;nbsp;&#39;s up to the given width.</span>
        &#34;pad&#34;: func(str string, width int) template.HTML {
            if len(str) &gt;= width {
                return template.HTML(html.EscapeString(str))
            }
            return template.HTML(html.EscapeString(str) + strings.Repeat(&#34;&amp;nbsp;&#34;, width-len(str)))
        },
    }
)

func NewTemplateLoader(paths []string) *TemplateLoader {
    loader := &amp;TemplateLoader{
        paths: paths,
    }
    return loader
}

<span class="comment">// This scans the views directory and parses all templates as Go Templates.</span>
<span class="comment">// If a template fails to parse, the error is set on the loader.</span>
<span class="comment">// (It&#39;s awkward to refresh a single Go Template)</span>
func (loader *TemplateLoader) Refresh() *Error {
    TRACE.Println(&#34;Refresh&#34;)
    loader.compileError = nil
    loader.templatePaths = map[string]string{}

    <span class="comment">// Walk through the template loader&#39;s paths and build up a template set.</span>
    var templateSet *template.Template = nil
    for _, basePath := range loader.paths {

        <span class="comment">// Walk only returns an error if the template loader is completely unusable</span>
        <span class="comment">// (namely, if one of the Funcs does not have an acceptable signature).</span>
        funcErr := filepath.Walk(basePath, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                ERROR.Println(&#34;error walking templates:&#34;, err)
                return nil
            }

            <span class="comment">// Walk into directories.</span>
            if info.IsDir() {
                if !loader.WatchDir(info) {
                    return filepath.SkipDir
                }
                return nil
            }

            if !loader.WatchFile(info.Name()) {
                return nil
            }

            <span class="comment">// If we already loaded a template of this name, skip it.</span>
            templateName := path[len(basePath)+1:]
            if os.PathSeparator == &#39;\\&#39; {
                templateName = strings.Replace(templateName, `\`, `/`, -1)
            }
            if _, ok := loader.templatePaths[templateName]; ok {
                return nil
            }
            loader.templatePaths[templateName] = path

            fileBytes, err := ioutil.ReadFile(path)
            if err != nil {
                ERROR.Println(&#34;Failed reading file:&#34;, path)
                return nil
            }

            fileStr := string(fileBytes)
            if templateSet == nil {
                <span class="comment">// Create the template set.  This panics if any of the funcs do not</span>
                <span class="comment">// conform to expectations, so we wrap it in a func and handle those</span>
                <span class="comment">// panics by serving an error page.</span>
                var funcError *Error
                func() {
                    defer func() {
                        if err := recover(); err != nil {
                            funcError = &amp;Error{
                                Title:       &#34;Panic (Template Loader)&#34;,
                                Description: fmt.Sprintln(err),
                            }
                        }
                    }()
                    templateSet = template.New(templateName).Funcs(Funcs)
                    _, err = templateSet.Parse(fileStr)
                }()

                if funcError != nil {
                    return funcError
                }

            } else {
                _, err = templateSet.New(templateName).Parse(fileStr)
            }

            <span class="comment">// Store / report the first error encountered.</span>
            if err != nil &amp;&amp; loader.compileError == nil {
                line, description := parseTemplateError(err)
                loader.compileError = &amp;Error{
                    Title:       &#34;Template Compilation Error&#34;,
                    Path:        templateName,
                    Description: description,
                    Line:        line,
                    SourceLines: strings.Split(fileStr, &#34;\n&#34;),
                }
                ERROR.Printf(&#34;Template compilation error (In %s around line %d):\n%s&#34;,
                    templateName, line, description)
            }
            return nil
        })

        <span class="comment">// If there was an error with the Funcs, set it and return immediately.</span>
        if funcErr != nil {
            loader.compileError = funcErr.(*Error)
            return loader.compileError
        }
    }

    <span class="comment">// Note: compileError may or may not be set.</span>
    loader.templateSet = templateSet
    return loader.compileError
}

func (loader *TemplateLoader) WatchDir(info os.FileInfo) bool {
    <span class="comment">// Watch all directories, except the ones starting with a dot.</span>
    return !strings.HasPrefix(info.Name(), &#34;.&#34;)
}

func (loader *TemplateLoader) WatchFile(basename string) bool {
    <span class="comment">// Watch all files, except the ones starting with a dot.</span>
    return !strings.HasPrefix(basename, &#34;.&#34;)
}

<span class="comment">// Return the Template with the given name.  The name is the template&#39;s path</span>
<span class="comment">// relative to a template loader root.</span>
<span class="comment">//</span>
<span class="comment">// An Error is returned if there was any problem with any of the templates.  (In</span>
<span class="comment">// this case, if a template is returned, it may still be usable.)</span>
func (loader *TemplateLoader) Template(name string) (Template, error) {
    <span class="comment">// Look up and return the template.</span>
    tmpl := loader.templateSet.Lookup(name)

    <span class="comment">// This is necessary.</span>
    <span class="comment">// If a nil loader.compileError is returned directly, a caller testing against</span>
    <span class="comment">// nil will get the wrong result.  Something to do with casting *Error to error.</span>
    var err error
    if loader.compileError != nil {
        err = loader.compileError
    }

    if tmpl == nil &amp;&amp; err == nil {
        return nil, fmt.Errorf(&#34;Template %s not found.&#34;, name)
    }

    return GoTemplate{tmpl, loader}, err
}

<span class="comment">// Adapter for Go Templates.</span>
type GoTemplate struct {
    *template.Template

}

<span class="comment">// return a &#39;rev.Template&#39; from Go&#39;s template.</span>
func (gotmpl GoTemplate) Render(wr io.Writer, arg interface{}) error {
    return gotmpl.Execute(wr, arg)
}

func (gotmpl GoTemplate) Content() []string {
    content, _ := ReadLines(gotmpl.loader.templatePaths[gotmpl.Name()])
    return content
}

<span class="comment">/////////////////////</span>
<span class="comment">// Template functions</span>
<span class="comment">/////////////////////</span>

<span class="comment">// Return a url capable of invoking a given controller method:</span>
<span class="comment">// &#34;Application.ShowApp 123&#34; =&gt; &#34;/app/123&#34;</span>
func ReverseUrl(args ...interface{}) string {
    if len(args) == 0 {
        ERROR.Println(&#34;Warning: no arguments provided to url function&#34;)
        return &#34;#&#34;
    }

    action := args[0].(string)
    actionSplit := strings.Split(action, &#34;.&#34;)
    var ctrl, meth string
    if len(actionSplit) != 2 {
        ERROR.Println(&#34;Warning: Must provide Controller.Method for reverse router.&#34;)
        return &#34;#&#34;
    }
    ctrl, meth = actionSplit[0], actionSplit[1]
    controllerType := LookupControllerType(ctrl)
    methodType := controllerType.Method(meth)
    argsByName := make(map[string]string)
    for i, argValue := range args[1:] {
        argsByName[methodType.Args[i].Name] = fmt.Sprintf(&#34;%s&#34;, argValue)
    }

    return MainRouter.Reverse(args[0].(string), argsByName).Url
}
</pre>






